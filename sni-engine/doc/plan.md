# SNI-engine 拡張計画: 現行仕様からの拡張ロードマップ

- 作成日: 2025-11-17  
- 最終更新: 2025-11-21 (投機スタックキーの爆発リスクを追記)  
- 対象: SNI 解析コア実装担当 (担当 C)  
- 関連: `spec.md`

本ドキュメントは、`spec.md` に記述された **現行実装仕様** を出発点として、  
どのような段階で、どのような変更を加えていくかを示す「実装ロードマップ」である。  
理論論文を読んでいない前提で書いているので、ここに出てくる用語はすべて本書内で簡単に定義する。

### 0.1 用語（このファイル内での意味）

- **投機実行 (Spec)**: CPU が分岐結果を予測して「とりあえず走らせてみる」実行。間違っていれば後でロールバックされる。
- **NS 実行 (Non-Spec)**: 実際にコミットされる通常の実行。
- **MEMLEAK**: load/store によるメモリアクセスの「アドレス」や「アクセスパターン」を通じて秘密 (High) が漏れること。  
  例: NS では常に Low のアドレスだけ読むが、Spec では秘密に依存して別のアドレスを読む。
- **CTRLLEAK**: 分岐やジャンプの「どちらの経路を通ったか」という制御フローを通じて秘密が漏れること。  
  例: NS では常に if の then 側だけ行くが、Spec では秘密に依存して else を通る。
- **O# (メモリ観測履歴)**: 「どのメモリ観測点で、Low/High どちらを見たか」を記録するマップ。
- **J# (制御観測履歴)**: 「どの分岐観測点で、どのような制御パターンを見たか」を記録するマップ。

ここで「理論仕様」と呼ぶのは、「O# と J# の両方を持ち、  
NS と Spec の観測を比較して MEMLEAK / CTRLLEAK の両方を検出できるような仕様」のことだと思ってもらえばよい。

## 1. ギャップ整理（現状アップデート）

現行実装は、以前のフェーズ 1〜3 で想定した多くの変更をすでに取り込んでいる。  
理論仕様との残存ギャップは次のとおり（未解決のみ列挙）:

1. **CTRLLEAK のターゲット粒度不足**  
   - **対応済み (2025-11-20):** `jmp` のターゲット式を `obsCtrl` に `pc:target:<expr>` 形式で観測し、NS/Spec 差分で Leak を検知するよう拡張。  
   - 残タスク: `beqz` のジャンプ先 PC も観測するかは未決定。

2. **観測キー命名の確定**  
   - 現行: `obsMem` は `"pc:addr"`, `obsCtrl` は 条件キー `pc` と ターゲットキー `pc:target:<expr>`。  
   - TODO: UI/ドキュメントで一貫したプレフィックス（例: `m:pc:addr`, `c:pc`, `c:pc:target` など）を定義し、`spec.md` を更新。

3. **テストの補完**  
   - 仕様で書いた例「値のみ High だがアドレス Low → 非違反」など、観測チャンネルの境界条件を含むテストが未追加。  
  - 条件観測／ターゲット観測で Leak が立つ・立たない境界ケースの網羅度を上げる。

## 2. 段階的な拡張フェーズ（更新版）

### フェーズ 0: 現行仕様の凍結
- 既存テストを回帰ベースラインとして維持（変更時は必ず差分を説明）。

### フェーズ 1: CTRLLEAK のターゲット観測拡張
- `jmp` / `beqz` のターゲット式ラベルを観測し、`obsCtrl` に `pc:target`（または選定したプレフィックス付きキー）で記録。
- UI への表示仕様とキー命名を `spec.md` に追記。
- DoD: ターゲットが Spec で High になることで Leak が立つテストを追加しパス。

### フェーズ 2: 観測キー命名・UI 整理
- `obsMem/obsCtrl` のキー命名規則をプレフィックス付きに統一し、UI 側での表示分類を明文化。
- `lib/analysis-schema/index.ts` のキー表示方針と揃うことを確認。
- DoD: 既存テストがキー変更後もパスし、UI で観測種別が正しくラベルされる。

### フェーズ 3: 観測境界テストの充実
- ケース追加: 「値のみ High だがアドレス Low → 非違反」「ターゲットのみ差分」など。
- MEM/CTRL それぞれで `EqLow/EqHigh/Leak` の遷移が期待通りになることを確認。
- DoD: 新規テストが追加され、CI 緑。

### フェーズ 4（任意）: 外部仕様比較と粒度調整
- SPECTECTOR などとの挙動差分を `spec.md` に表でまとめ、格子の扱い (`Diverge/Top`) を再調整するか判断。
- 追加するならベンチマークケースと計測手順を列挙。

## 3. DoD（Definition of Done）サマリ
- フェーズ 1〜3 で追加する各テストが `vitest` でグリーン。CI にスイート追加。 
- `spec.md` に: 新しい状態型、観測キー仕様、射影ルール、漏洩判定表を反映。 
- 既存テストの期待値が変わる場合、理由をテスト名またはコメントに明記。 
- `sni-engine/src` の型・ロジックと `lib/analysis-schema/index.ts` の表示仕様が不整合を起こさないことを PR で相互確認。 
- 性能: 既存ベンチ（`iterationCap=10_000` 相当）でタイムアウトしないことを簡易実測し、結果を PR コメントに記録。

## 4. リスクとトレードオフ

- 関係的値ドメイン導入で状態空間が増大し、反復回数が増える可能性。軽量化策として観測キーの粒度調整を並行検討。  
- CTRLLEAK 精緻化は VCFG-builder に分岐方向情報がどこまで供給されるかに依存。供給できない場合は conservative な Top を使い誤検知が増える点を許容する。

小さな PR 単位（フェーズ 1→2→3）で進め、各段階のテスト追加を必須とする方針を維持する。

## 5. 理論ノートとの整合状況メモ（2025-11-17 時点）

ここでは、別途整理した理論ノート「投機的非干渉（SNI）検証のための関係的抽象解釈」と、  
現行実装（`sni-engine/lib/*`, `vcfg-builder/lib/*`）の対応関係を簡単に記録しておく。  
詳細な数式展開は理論ノート側に譲り、実装観点での差分だけを列挙する。

### 5.1 一致しているポイント（大枠）

- **VCFG 構造**  
  - （2025-11 時点の実装では `meta` モードを廃止し、`vcfg-builder/lib/modes/meta.ts` も削除済み。以下は旧実装の記録。）  
    `beqz` / `bnez` は通過条件をラベルに持つ 2 本の NS エッジを張り、分岐ごとに Always-mispredict で両方向の投機を展開する（meta 構造を共通で使用）。

- **抽象状態 Σ# = (R#, Γ#, O#, J#)**  
  - `AbsState`（`sni-engine/src/state.ts`）が `regs`, `mem`, `obsMem`, `obsCtrl` の 4 成分を持ち、  
    理論ノートの \(R^\#, \Gamma^\#, \mathcal{O}^\#, \mathcal{J}^\#\) に対応している。  
  - `RelValue = { ns, sp }` として NS/SP 成分を分離し、必要に応じて `join(ns, sp)` で関係格子に射影する設計。

- **格子 L_SNI^# と F_ns / F_spec**  
  - `lattice.ts` の `LatticeValue` と `JOIN_TABLE` が、理論ノートで定義した 6 要素格子（Bot/EqLow/EqHigh/Diverge/Leak/Top）とその順序に一致。  
  - `applyInstruction` 内で、NS モードでは NS/SP 成分を対称に更新し、Spec モードでは SP 成分のみ更新する（`setValue` 経由）。  
    → 理論上の F_ns（対称）/F_spec（非対称）と同じ構造になっている。

- **観測履歴 O# / J# と MEMLEAK/CTRLLEAK**  
  - メモリ観測: `obsMem` を `"pc:addr"` キーで管理し、`updateMemObsNS` / `updateMemObsSpec` が  
    「NS で High 観測済みならベースライン、NS では Low/⊥ だが Spec で High なら Leak」という表 2 のルールを実装。  
  - 制御観測: `obsCtrl` を 条件キー `pc` と ターゲットキー `pc:target:<expr>` の 2 種のキーで管理し、  
    `updateCtrlObsNS` / `updateCtrlObsSpec` が MEMLEAK と同じパターンで CTRLLEAK を検出する。  
  - `stateHasViolation` は O#/J# に Leak/Top が現れたかだけを見るため、違反判定ロジックも理論と対応している。

- **不動点計算と Pruning-VCFG**  
  - `analyzeVCFG` は (nodeId, Mode) ごとの `AbsState` を保持するワークリスト型のモノトーンフレームワーク。  
  - VCFG は `ns/spec` エッジのみで rollback エッジを生成せず、投機ウィンドウが尽きた spec エッジは探索を打ち切る（Prune）。  
    観測履歴は同一路上で継続する。

### 5.2 理論仕様からの主な簡略化・ギャップ

- **J# の粒度（ターゲットアドレス未追跡）**  
  - 現実装の J# は「条件レジスタの High/Low」「分岐方向の High/Low」のみを観測対象としており、  
    `jmp` や `beqz` の「ターゲットアドレスの関係性」までは抽象化していない。  
  - そのため、symPc(se) における「ターゲット差分」を使うような、より精密な CTRLLEAK 定義とはまだギャップがある。

- **観測値の 2 値化**  
  - O#/J# に格納する値は、観測時点では High/Low の 2 値レベルに潰し、その後の join で Leak/Top へ遷移させる設計。  
  - 理論上は L_SNI^# 全体（EqLow/EqHigh/Diverge/Leak/Top）を履歴に持つ形もあり得るが、  
    現実装では計算量と UI 単純化のために「High/Low→Leak/Top」に限定している。

- **仮想ノード (vn_start/vn_stop) の表現方法**  
  - 理論ノートが想定する明示的な仮想ノード（投機開始/終了ノード）は導入していない。  
  - 代わりに、`type:"spec"` のノード複製のみで投機区間を表現し、rollback エッジは生成しない。  
  - NS/SP の分離と投機ウィンドウによる探索打ち切りという現実装の要件に合わせている。

- **完全なハイパープロパティとしての SNI**  
  - 理論ノートは 2-ハイパープロパティとしての完全な SNI（トレース同値など）を視野に入れているが、  
    現行実装は「投機実行でのみ追加で観測される High 情報（メモリ/制御）」の検出にフォーカスしている。  
  - つまり、SPECTECTOR の MEMLEAK/CTRLLEAK に相当する部分の sound な抽象解釈版であり、  
    トレース同値性そのものまでは扱っていない。

### 5.3 今後の拡張の位置づけ

- 本ファイルのフェーズ 1〜3 は、上記ギャップのうち特に CTRLLEAK の粒度と観測の境界テストを埋めていく計画に対応している。  
- 専門的には「J# のキー設計と観測値の抽象度」をどうするかが中心論点であり、  
  必要に応じて L_SNI^# のより細かい利用（Diverge の活用など）やターゲットアドレス観測を追加していく余地がある。  
- これ以上の理論仕様への追従（完全なトレース同値性など）が必要になった場合は、  
  別セクション（フェーズ 4 以降）として明示し、このメモを更新する。

## 6. 本メモに未記載だった追加ギャップと対応タスク

- **方向観測の扱い**  
  - 現状: `beqz/bnez` は条件レベルのみを観測し、方向キーを生成していないため方向差分だけでは Leak 判定を行わない。  
  - 対応: 方向観測を導入するか、現状非対応を仕様に明記するかを決め、結果を `analysis.ts` とテスト・`spec.md` に反映する。

- **メモリ観測キーの粒度再検討**  
  - 現状: `obsMem` キーが `pc:addr式` のため、同一 PC でもアドレス式ごとに履歴が分散し、漏洩検知が弱まる可能性。  
  - 対応: (A) PC 単位に粗くする、(B) 現行粒度を維持しつつ意図をドキュメント化、のいずれかを決定し、選択理由とテストを追加。

- **VCFG の spec/rollback 構造チェック**  
  - 現状: 入力グラフに投機開始ノードが欠落しても検知しない。  
  - 対応: `parseGraph` または `analyzeVCFG` で必須構造（spec ノード存在）を検証し、欠落時は警告またはエラーとするバリデーションを追加。設計選択を `spec.md` に追記。
- **投機スタックキーの爆発リスク**  
  - 現状: `analyzeVCFG` はモードキーを `"Speculative|ctxA::ctxB::..."` の全長連結で保持し、k-limiting やハッシュ縮約を行っていない（参照: `sni-engine/lib/analysis/analyze.ts:112-116,309-335`）。深いネストや多量の分岐で状態数が急増しうる。  
  - 対応案: (A) スタック長のみをキーにする近似、(B) 先頭/末尾 k 個を保持する k-limiting、(C) ハッシュしたキーに衝突検出を組み合わせる、のいずれかを選定。まず (A) を実験実装し、精度/性能の劣化を `vitest` 追加ケースとベンチで評価する。
