# SNI-engine 拡張計画: 現行仕様からの拡張ロードマップ

- 作成日: 2025-11-17  
- 最終更新: 2025-11-17 (実装差分整理)  
- 対象: SNI 解析コア実装担当 (担当 C)  
- 関連: `spec.md`

本ドキュメントは、`spec.md` に記述された **現行実装仕様** を出発点として、  
どのような段階で、どのような変更を加えていくかを示す「実装ロードマップ」である。  
理論論文を読んでいない前提で書いているので、ここに出てくる用語はすべて本書内で簡単に定義する。

### 0.1 用語（このファイル内での意味）

- **投機実行 (Spec)**: CPU が分岐結果を予測して「とりあえず走らせてみる」実行。間違っていれば後でロールバックされる。
- **NS 実行 (Non-Spec)**: 実際にコミットされる通常の実行。
- **MEMLEAK**: load/store によるメモリアクセスの「アドレス」や「アクセスパターン」を通じて秘密 (High) が漏れること。  
  例: NS では常に Low のアドレスだけ読むが、Spec では秘密に依存して別のアドレスを読む。
- **CTRLLEAK**: 分岐やジャンプの「どちらの経路を通ったか」という制御フローを通じて秘密が漏れること。  
  例: NS では常に if の then 側だけ行くが、Spec では秘密に依存して else を通る。
- **O# (メモリ観測履歴)**: 「どのメモリ観測点で、Low/High どちらを見たか」を記録するマップ。
- **J# (制御観測履歴)**: 「どの分岐観測点で、どのような制御パターンを見たか」を記録するマップ。

ここで「理論仕様」と呼ぶのは、「O# と J# の両方を持ち、  
NS と Spec の観測を比較して MEMLEAK / CTRLLEAK の両方を検出できるような仕様」のことだと思ってもらえばよい。

## 1. ギャップ整理（現状アップデート）

現行実装は、以前のフェーズ 1〜3 で想定した多くの変更をすでに取り込んでいる。  
理論仕様との残存ギャップは次のとおり（未解決のみ列挙）:

1. **CTRLLEAK のターゲット粒度不足**  
   - 現行: 分岐条件 (`pc` キー) と分岐方向 (`pc:dir` キー) を観測済み。`jmp` のターゲット式や `beqz` のターゲット PC は観測していない。  
   - TODO: ターゲットアドレスの抽象ラベルを観測履歴に記録するか判断し、UI キー形式を決める。

2. **観測キー命名の確定**  
   - 現行: `obsMem` は `"pc:addr"`, `obsCtrl` は `pc`, `pc:dir`。  
   - TODO: UI/ドキュメントで一貫したプレフィックス（例: `m:pc:addr`, `c:pc:dir`, `c:pc:target` など）を定義し、`spec.md` を更新。

3. **テストの補完**  
   - 仕様で書いた例「値のみ High だがアドレス Low → 非違反」など、観測チャンネルの境界条件を含むテストが未追加。  
   - 方向観測が Leak になる/ならないケースの網羅度を上げる。

## 2. 段階的な拡張フェーズ（更新版）

### フェーズ 0: 現行仕様の凍結
- 既存テストを回帰ベースラインとして維持（変更時は必ず差分を説明）。

### フェーズ 1: CTRLLEAK のターゲット観測拡張
- `jmp` / `beqz` のターゲット式ラベルを観測し、`obsCtrl` に `pc:target`（または選定したプレフィックス付きキー）で記録。
- UI への表示仕様とキー命名を `spec.md` に追記。
- DoD: ターゲットが Spec で High になることで Leak が立つテストを追加しパス。

### フェーズ 2: 観測キー命名・UI 整理
- `obsMem/obsCtrl` のキー命名規則をプレフィックス付きに統一し、UI 側での表示分類を明文化。
- `lib/analysis-schema/index.ts` のキー表示方針と揃うことを確認。
- DoD: 既存テストがキー変更後もパスし、UI で観測種別が正しくラベルされる。

### フェーズ 3: 観測境界テストの充実
- ケース追加: 「値のみ High だがアドレス Low → 非違反」「方向観測のみ差分」「ターゲットのみ差分」など。
- MEM/CTRL それぞれで `EqLow/EqHigh/Leak` の遷移が期待通りになることを確認。
- DoD: 新規テストが追加され、CI 緑。

### フェーズ 4（任意）: 外部仕様比較と粒度調整
- SPECTECTOR などとの挙動差分を `spec.md` に表でまとめ、格子の扱い (`Diverge/Top`) を再調整するか判断。
- 追加するならベンチマークケースと計測手順を列挙。

## 3. DoD（Definition of Done）サマリ
- フェーズ 1〜3 で追加する各テストが `vitest` でグリーン。CI にスイート追加。 
- `spec.md` に: 新しい状態型、観測キー仕様、射影ルール、漏洩判定表を反映。 
- 既存テストの期待値が変わる場合、理由をテスト名またはコメントに明記。 
- `sni-engine/src` の型・ロジックと `lib/analysis-schema/index.ts` の表示仕様が不整合を起こさないことを PR で相互確認。 
- 性能: 既存ベンチ（`iterationCap=10_000` 相当）でタイムアウトしないことを簡易実測し、結果を PR コメントに記録。

## 4. リスクとトレードオフ

- 関係的値ドメイン導入で状態空間が増大し、反復回数が増える可能性。軽量化策として観測キーの粒度調整を並行検討。  
- CTRLLEAK 精緻化は VCFG-builder に分岐方向情報がどこまで供給されるかに依存。供給できない場合は conservative な Top を使い誤検知が増える点を許容する。

小さな PR 単位（フェーズ 1→2→3）で進め、各段階のテスト追加を必須とする方針を維持する。

## 5. 理論ノートとの整合状況メモ（2025-11-17 時点）

ここでは、別途整理した理論ノート「投機的非干渉（SNI）検証のための関係的抽象解釈」と、  
現行実装（`sni-engine/src/*`, `vcfg-builder/src/*`）の対応関係を簡単に記録しておく。  
詳細な数式展開は理論ノート側に譲り、実装観点での差分だけを列挙する。

### 5.1 一致しているポイント（大枠）

- **VCFG 構造**  
  - `vcfg-builder/src/vcfg.ts` で、通常ノード `type:"ns"` と投機ノード `type:"spec"`、および `type:"rollback"` エッジを明示的に分離。  
  - `beqz` は taken/not-taken の 2 本の NS エッジを張り、分岐ごとに「Always mispredict」で両方向の投機パスを展開している。

- **抽象状態 Σ# = (R#, Γ#, O#, J#)**  
  - `AbsState`（`sni-engine/src/state.ts`）が `regs`, `mem`, `obsMem`, `obsCtrl` の 4 成分を持ち、  
    理論ノートの \(R^\#, \Gamma^\#, \mathcal{O}^\#, \mathcal{J}^\#\) に対応している。  
  - `RelValue = { ns, sp }` として NS/SP 成分を分離し、必要に応じて `join(ns, sp)` で関係格子に射影する設計。

- **格子 L_SNI^# と F_ns / F_spec**  
  - `lattice.ts` の `LatticeValue` と `JOIN_TABLE` が、理論ノートで定義した 6 要素格子（Bot/EqLow/EqHigh/Diverge/Leak/Top）とその順序に一致。  
  - `applyInstruction` 内で、NS モードでは NS/SP 成分を対称に更新し、Spec モードでは SP 成分のみ更新する（`setValue` 経由）。  
    → 理論上の F_ns（対称）/F_spec（非対称）と同じ構造になっている。

- **観測履歴 O# / J# と MEMLEAK/CTRLLEAK**  
  - メモリ観測: `obsMem` を `"pc:addr"` キーで管理し、`updateMemObsNS` / `updateMemObsSpec` が  
    「NS で High 観測済みならベースライン、NS では Low/⊥ だが Spec で High なら Leak」という表 2 のルールを実装。  
  - 制御観測: `obsCtrl` を `pc`（条件値）と `pc:dir`（taken/not-taken）の 2 種のキーで管理し、  
    `updateCtrlObsNS` / `updateCtrlObsSpec` が MEMLEAK と同じパターンで CTRLLEAK を検出する。  
  - `stateHasViolation` は O#/J# に Leak/Top が現れたかだけを見るため、違反判定ロジックも理論と対応している。

- **不動点計算とロールバック**  
  - `analyzeVCFG` は (nodeId, Mode) ごとの `AbsState` を保持するワークリスト型のモノトーンフレームワーク。  
  - `rollback` エッジでは regs/mem を捨て、obsMem/obsCtrl のみを別状態にコピーしてマージする実装になっており、  
    「ロールバック後も観測履歴は残る」という投機実行モデルと整合している。

### 5.2 理論仕様からの主な簡略化・ギャップ

- **J# の粒度（ターゲットアドレス未追跡）**  
  - 現実装の J# は「条件レジスタの High/Low」「分岐方向の High/Low」のみを観測対象としており、  
    `jmp` や `beqz` の「ターゲットアドレスの関係性」までは抽象化していない。  
  - そのため、symPc(se) における「ターゲット差分」を使うような、より精密な CTRLLEAK 定義とはまだギャップがある。

- **観測値の 2 値化**  
  - O#/J# に格納する値は、観測時点では High/Low の 2 値レベルに潰し、その後の join で Leak/Top へ遷移させる設計。  
  - 理論上は L_SNI^# 全体（EqLow/EqHigh/Diverge/Leak/Top）を履歴に持つ形もあり得るが、  
    現実装では計算量と UI 単純化のために「High/Low→Leak/Top」に限定している。

- **仮想ノード (vn_start/vn_stop) の表現方法**  
  - 理論ノートが想定する明示的な仮想ノード（投機開始/終了ノード）は導入していない。  
  - 代わりに、`type:"spec"` のノード複製と `type:"rollback"` エッジで同等のセマンティクスを表現している。  
  - 表現は異なるが、NS/SP の構造的分離とロールバック挙動という本質的要件は満たしている。

- **完全なハイパープロパティとしての SNI**  
  - 理論ノートは 2-ハイパープロパティとしての完全な SNI（トレース同値など）を視野に入れているが、  
    現行実装は「投機実行でのみ追加で観測される High 情報（メモリ/制御）」の検出にフォーカスしている。  
  - つまり、SPECTECTOR の MEMLEAK/CTRLLEAK に相当する部分の sound な抽象解釈版であり、  
    トレース同値性そのものまでは扱っていない。

### 5.3 今後の拡張の位置づけ

- 本ファイルのフェーズ 1〜3 は、上記ギャップのうち特に CTRLLEAK の粒度と観測の境界テストを埋めていく計画に対応している。  
- 専門的には「J# のキー設計と観測値の抽象度」をどうするかが中心論点であり、  
  必要に応じて L_SNI^# のより細かい利用（Diverge の活用など）やターゲットアドレス観測を追加していく余地がある。  
- これ以上の理論仕様への追従（完全なトレース同値性など）が必要になった場合は、  
  別セクション（フェーズ 4 以降）として明示し、このメモを更新する。
