# SNI検証ツール (SPECTECTOR拡張版) Webアプリケーション仕様書

- 作成日: 2025年11月17日  
- 更新日: 2025年11月17日 (Rev 3: UI 詳細仕様の統合)  
- 版数: 2.1  
- 対象: SNI 検証アルゴリズムの研究・実証用プロトタイプ

## 1. システム概要

本システムは、MuASM プログラムを入力とし、提案手法である「VCFG（仮想制御フローグラフ）」と「抽象解釈」を用いた SNI（投機的非干渉）検証プロセスの動作を、ブラウザ上で視覚的に確認するための Web アプリケーションである。

### 1.1 主要な要件

- **クライアントサイド完結**  
  サーバー処理を介さず、ブラウザ上の JavaScript / WASM のみで動作すること。
- **疎結合アーキテクチャ**  
  「解析エンジン（Logic）」と「可視化 UI（View）」を分離する。  
  解析手法の変更（抽象ドメインの変更など）に対して UI の変更を最小限に抑えるため、汎用的なデータ駆動型 UI を採用する。
- **ステップ実行**  
  解析の過程（不動点計算またはトレース実行）をコマ送りで可視化し、各ステップにおける抽象状態の変化を確認できること。

## 2. アーキテクチャとデータインターフェース

UI とエンジンを分離するため、両者の間でやり取りされるデータ構造（JSON スキーマ）を厳密に定義する。UI はこのデータ構造のみに依存して描画を行う。

### 2.1 解析エンジン インターフェース

UI コンポーネントは、エンジン統合ファサード（MuASM → VCFG → SNI 解析を直列に実行するブラウザ内モジュール）に対して以下のメソッドを通じて解析をリクエストする。

```ts
interface AnalysisEngine {
  /**
   * ソースコードを入力とし、解析結果全体を返す（非同期）。
   * 解析結果には、静的なグラフ構造と、動的な実行トレースが含まれる。
   */
  analyze(sourceCode: string): Promise<AnalysisResult>;
}
```

### 2.2 データ構造定義 (AnalysisResult)

解析結果オブジェクトは以下の構造を持つ。`schemaVersion` を基準に互換性を管理する。

```ts
// 共通スキーマは `app/types/analysis-result.ts` を単一の出典とする。
// 以下は概要のみ（詳細は同ファイルを参照）。投機コンテキストでは必ず
// ノードを複製し、type: "spec" を付ける。

interface AnalysisResult {
  schemaVersion: "1.0.0";
  graph: StaticGraph;
  trace: ExecutionTrace;
  result: "Secure" | "SNI_Violation";
  error?: AnalysisError;
}
```

- **StaticGraph（静的構造）**: VCFG の形状（ノードとエッジ）
- **ExecutionTrace（動的挙動）**: ステップごとの状態スナップショット
- **Summary（結果）**: `result` と `error`

#### A. StaticGraph (VCFG 構造)

描画用のグラフデータ。

| フィールド | 型       | 説明                           |
| ---------- | -------- | ------------------------------ |
| `nodes`    | `Node[]` | グラフのノードリスト          |
| `edges`    | `Edge[]` | ノード間をつなぐエッジリスト  |

```ts
type Node = {
  id: string;
  pc: number;       // 必須: ソース行番号/PC。Obs ID の安定キー。
  label: string;
  type: "ns" | "spec"; // 投機コンテキストでは必須で spec
  instruction?: string; // 任意: 元命令文字列（ツールチップ等で利用可）
  sourceLine?: number;
  specOrigin?: string; // 投機開始元ノード ID（複製時に付与）
  x?: number;
  y?: number;
};

type Edge = {
  source: string;
  target: string;
  type: "ns" | "spec" | "rollback";
  label?: string;
};
```

- `type`: ノード／エッジの種類（通常、投機、ロールバック）で色分け・線種に使用する。

#### B. ExecutionTrace (実行トレース)

UI の「コマ送り」で表示されるステップデータの配列。各ステップは特定の時点における全状態を持つ（完全なスナップショット）。

| フィールド | 型       | 説明                         |
| ---------- | -------- | ---------------------------- |
| `steps`    | `Step[]` | 時系列順のステップ配列       |

```ts
type Step = {
  stepId: number;              // 0 からの連番
  nodeId: string;              // 現在実行中の VCFG ノード ID（ハイライト用）
  description: string;         // 「現在何をしているか」の説明文
  executionMode: "NS" | "Speculative"; // 現在の実行モード
  state: AbstractState;        // その時点での抽象状態の詳細
  isViolation: boolean;        // このステップで SNI 違反が確定したか
};
```

#### C. AbstractState (抽象状態詳細 - 汎用構造)

特定の手法（Registers, Memory 等）に依存しないよう、「セクション」のリストとして定義する。UI は受け取ったセクションを順に表示する。

```ts
interface AbstractState {
  sections: StateSection[];
}

interface StateSection {
  id: string;          // 内部識別子 (例: "registers", "constraints")
  title: string;       // 表示タイトル (例: "Abstract Registers", "Path Conditions")
  type: "key-value";   // 将来的に 'list', 'graph' 等を追加可能
  data: Record<string, DisplayValue>; // 表示するデータのペア
  description?: string; // セクションの解説（ロジックの説明など）
  alert?: boolean;      // このセクションで異常（Leak など）が発生しているか
}
```

#### D. DisplayValue (表示用抽象値)

具体的な格子値（`"EqLow"` など）を固定せず、UI が表示すべき「ラベル」と「意味的スタイル」を定義する。

```ts
interface DisplayValue {
  label: string;       // UI に表示する文字列 (例: "EqLow", "⊥", "[0, 10]")
  style: "neutral" | "safe" | "warning" | "danger" | "info"; // 色分け用セマンティクス
  description?: string; // ホバー時に表示する補足情報など
}
```

**Style Mapping（推奨）**

- `neutral`: 灰色 (Bot など)
- `safe`: 緑 (EqLow, Low など)
- `warning`: オレンジ (EqHigh, High など)
- `danger`: 赤 (Leak, SNI 違反など)
- `info`: 青 (Diverge, その他情報)

## 3. 画面仕様 (UI デザイン)

画面はシングルページで構成し、左右 2 ペイン分割レイアウトを採用する。

### 3.1 画面レイアウト概略

```text
+-------------------------------------------------------+
|  ヘッダー (タイトル, 最終判定ステータス表示)          |
+---------------------------+---------------------------+
| [左ペイン: 入力と制御]    | [右ペイン: 可視化]        |
|                           |                           |
| 1. コードエディタ         | 3. VCFG ビジュアライザ    |
|    (MuASM)                |    (SVG グラフ描画)       |
|                           |                           |
| ------------------------- | ------------------------- |
| 2. コントロールパネル     | 4. 汎用ステートビューワ   |
|    [解析] [<<] [>] [>>]   |    (セクション動的描画)   |
|    現在のステップ説明     |                           |
+---------------------------+---------------------------+
```

### 3.2 各コンポーネントの詳細仕様

#### 1. コードエディタ (Source Code Input)

- 機能: ユーザーが MuASM コードを記述・編集する。
- 初期値: デモ用に「問題のケース（`ptr++` ループ）」のコードをプリセットする。
- 挙動: テキスト変更時は解析結果をクリアする（解析結果との不整合を防ぐため）。

#### 2. コントロールパネル (Control Panel)

- **解析実行ボタン**  
  - 押下時、エディタの内容をエンジンに渡し、`AnalysisResult` を取得する。  
  - 成功時、ステップを 0 にリセットし、右ペインを更新する。
- **再生コントロール**
  - `Prev`: ステップを 1 つ戻す（`stepId > 0` の時のみ有効）。
  - `Next`: ステップを 1 つ進める（`stepId < max` の時のみ有効）。
  - `Reset`: ステップ 0 に戻る。
  - `Auto Play`: 自動的に一定間隔で `Next` を実行するトグルボタン。
- **ステップ情報表示**
  - 現在のステップ番号
  - 実行モード（NS / Spec）
  - エンジンの出力した `description`

#### 3. VCFG ビジュアライザ (VCFG View)

- 描画: `AnalysisResult.graph` の情報に基づき、ノードとエッジを描画する。
- ノード・エッジの表現例:
  - `type: "ns"` → 青色系、実線
  - `type: "spec"` → 赤色系、実線（投機的実行パスを強調）
  - `type: "rollback"` → 灰色、点線
- 現在位置の強調:  
  現在のステップの `nodeId` に該当するノードを、太枠や影付き、あるいは点滅アニメーションで強調表示する。
- インタラクション（オプション）:  
  ノードをクリックすると、そのノードが実行された直近のステップへジャンプする機能。

#### 4. 汎用ステートビューワ (Generic State Viewer)

以前の「ステートインスペクタ」をリプレースするもの。エンジンから受け取った `AbstractState.sections` 配列をイテレーションし、動的にテーブルを生成する。

- レンダリングロジック:
  - `sections` 配列を展開し、各セクションについてタイトルと説明を表示。
  - `alert` フラグが `true` の場合、そのセクション全体を赤枠で囲む、または警告アイコンを表示するなどしてユーザーの注意を強く引く（Leak 発生時など）。
  - `data` (Key-Value) をテーブル形式で描画。
  - Key: そのまま表示。
  - Value (`DisplayValue`): `label` を表示し、`style` に基づいてバッジの色を決定する。

- 共通仕様（Lattice バッジ）:
  - 格子値は、単なるテキストではなく、`DisplayValue.style` に基づき色付きのバッジとして表示する。
    - `safe`: 緑 (EqLow など)
    - `warning`: オレンジ (EqHigh など)
    - `danger`: 赤（強調・点滅）(Leak など)
    - `info` / その他: 青・紫など

- 標準的なセクション構成例:
  - **A. Register Table (\(R^\#\))**:  
    レジスタ名と抽象値。前ステップと比較して値が変化した行をハイライトする。
  - **B. Observation Table (\(\mathcal{O}^\#\))**:  
    観測 ID と抽象値。ここでの `danger` スタイル（Leak）が SNI 違反の直接的な証拠となるため、特に重要である。

### 3.3 エラーハンドリング (Toast)

- `AnalysisResult.error` を受領した場合、画面上部に Toast を表示しメッセージを提示する。
- Toast には「再解析」ボタンを含め、同一入力でリトライできる動線を設ける。
- エラー発生中はステップ送り UI を無効化し、トレース／VCFG ペインにはプレースホルダーを表示する。

## 4. ユーザー体験 (UX) フロー

### 初期ロード時

- デフォルトのサンプルコードがエディタに入力されている。
- 解析は未実行状態。右ペインはプレースホルダー表示。

### 解析実行

- ユーザーが「解析実行」ボタンを押す。
- エンジンが実行され、データがメモリ上に展開される。
- ステップ 0（初期状態）が表示される。VCFG の「Loop Head」などがハイライトされる。

### ステップ送り (NS 実行フェーズ)

- ユーザーが「Next」を押す。
- 通常実行（NS）パスが進む。
- レジスタの値が `EqLow` や `EqHigh` に変化していく様子を確認する。
- \(\mathcal{O}^\#\) には `EqLow`（Low アドレスへのアクセス）などが記録される。

### ステップ送り (Spec 実行フェーズ)

- ある時点で分岐予測ミスが発生し、実行モードが `Speculative` に切り替わる（VCFG 上の赤色ノードへ移動）。
- ユーザーは、「NS 実行で作られた状態（`EqHigh` など）」が投機実行に引き継がれる様子を見る。

### 決定的瞬間

- 投機実行中に、あるメモリアクセスの観測値が `Leak` になる瞬間を「Next」で目撃する。
- Observation Table（または該当セクション）が警告色に変わる。

### 完了

- 最終ステップまで進むか、違反を確認して停止する。

## 5. 今後の拡張性への配慮

- **エンジンの WebWorker 化**  
  解析処理が重くなった場合、UI スレッドをブロックしないよう WebWorker へ分離可能なインターフェース設計とする（`analyze` メソッドを非同期にし、`Promise` を返す形にする）。

- **グラフライブラリの選定**  
  プロトタイプでは簡易 SVG で良いが、ノード数が増えた場合は React Flow や Vis.js などのライブラリ導入を検討する。  
  今回はデータ構造をグラフライブラリに依存させない（中間形式 `StaticGraph` を挟む）ことで、ライブラリの差し替えを容易にする。
