# 仮想制御フローグラフ上の関係抽象解釈による投機的非干渉（SNI）検証の形式的拡張に関する包括的研究報告書

## 第I章 エグゼクティブサマリー

本報告書は、現代のプロセッサにおける投機的実行（Speculative Execution）に起因するサイドチャネル脆弱性、特にSpectreバリアントに対する防御メカニズムの検証手法に関する研究提案を包括的に評価し、その妥当性と新規性を論じるものである。提案されている主要なアプローチは、従来のシンボリック実行（Symbolic Execution）に基づくツールであるSPECTECTORが抱えるスケーラビリティの課題、とりわけパス爆発（Path Explosion）問題を克服するために、仮想制御フローグラフ（Virtual Control Flow Graph, VCFG）上での関係抽象解釈（Relational Abstract Interpretation）を採用するというものである。

本評価において特筆すべき結論は、提案手法が単なる既存手法の改良にとどまらず、投機的実行のセマンティクスを静的解析のグラフ構造と抽象ドメインに深く統合する、数学的に健全かつ堅牢なフレームワークを構築している点である。特に、初期の「ループ展開仮説」が抱えていた論理的な破綻（偽の不動点への収束問題）を正しく認識し、それを克服するために導入された「投機コンテキストスタック（Speculative Context Stack）」は、グラフベースの解析において文脈感度（Context Sensitivity）を維持するための決定的な革新であると評価できる。これにより、解析器はハードウェアのリオーダーバッファ（ROB）の挙動を抽象レベルで模倣し、実現不可能なパスの探索を効果的に排除することが可能となる。

また、本報告書では、関連研究であるWuとWangによるキャッシュ解析のための抽象解釈手法や、LightSLHにおける「解析麻痺（Analysis Paralysis）」への対策としての不動点アルゴリズムとの比較分析を行う。これにより、提案手法がSPECTECTORのような完全性（Completeness）と引き換えに、大規模な暗号ライブラリやカーネルコードに対しても適用可能な多項式時間の検証能力を獲得しているというトレードオフを明らかにする。さらに、コンパイラが導入する微細な脆弱性（スタックスピル等）への対応能力や、ビットレベルのテイント追跡による精度の向上といった観点からも、本手法の優位性と課題を浮き彫りにする。

結論として、本研究の方向性は極めて有望であり、特に自動化されたセキュリティ認証やCI/CDパイプラインにおけるゲートキーパーとしての役割において、既存の最先端技術を凌駕するポテンシャルを有していると判断される。

## 第II章 序論：投機的実行の安全性検証における構造的課題とパラダイムシフト

### 2.1 現代プロセッサの暗部：投機的実行とSpectreの脅威

現代の高性能プロセッサアーキテクチャにおいて、投機的実行は性能向上のための不可欠な機能として定着している。分岐予測器が将来の実行パスを予測し、その結果が確定する前に命令を投機的に実行することで、プロセッサはメモリレイテンシを隠蔽し、命令スループットを最大化する。予測が正しければ、計算結果はアーキテクチャ状態（レジスタやメインメモリ）にコミットされ、プログラムの実行は遅延なく進行する。しかし、予測が誤っていた場合、プロセッサは投機的に実行された命令の影響をロールバックし、正しいパスへ復帰しなければならない。
問題の本質は、このロールバックプロセスが不完全である点にある。アーキテクチャ状態は正しく復元されるものの、キャッシュや分岐予測バッファ（BTB）といったマイクロアーキテクチャ状態には、投機実行の痕跡（サイドエフェクト）が残留する場合がある。Spectre攻撃は、この残留した痕跡を観測することによって、本来アクセス権限のない機密情報を推測する手法である。攻撃者は、犠牲者プログラムの誤予測を誘発し、機密データに依存したメモリアクセスや制御フロー遷移を投機的に実行させることで、キャッシュの状態を変化させ、その変化をサイドチャネル（例えば、メモリアクセス時間の測定）を通じて読み取る。

### 2.2 投機的非干渉（SNI）：セキュリティの形式的定義

このような攻撃を防ぐための形式的なセキュリティ性質として定義されるのが、「投機的非干渉（Speculative Non-Interference, SNI）」である。SNIは、単一の実行トレースの健全性を問う安全性プロパティ（Safety Property）ではなく、複数の実行トレース間の関係性を問う「2-ハイパープロパティ（2-Hyperproperty）」として分類される。
形式的には、プログラム $P$ と、攻撃者が観測可能な低セキュリティレベル（Low）の等価関係 $\approx_L$ について、以下の条件が満たされるとき、プログラムはSNIを満たすとされる。

$$\forall \sigma_1, \sigma_2. \quad \sigma_1 \approx_L \sigma_2 \implies \mathcal{O}_{sp}(\sigma_1) = \mathcal{O}_{sp}(\sigma_2)$$

ここで、$\sigma_1, \sigma_2$ は初期状態であり、$\mathcal{O}_{sp}$ は投機的実行を含む観測トレース（メモリアドレスやプログラムカウンタの遷移列）を表す。この定義は、「攻撃者にとって初期状態の区別がつかないならば（機密部分のみが異なるならば）、投機的実行を通じても観測結果に差異が生じてはならない」ということを意味する。すなわち、投機的実行が機密情報の差異を「漏洩」してはならないという厳格な要件である。

### 2.3 既存技術の限界：シンボリック実行とパス爆発

現在、SNI検証のゴールドスタンダードとされているのが、Guarnieriらによって開発されたツール「SPECTECTOR」である。SPECTECTORはシンボリック実行（Symbolic Execution）を採用しており、プログラムの変数を具体的な値ではなく記号として扱い、実行パスごとの制約条件（Path Condition）を収集する。そして、SMTソルバ（Z3など）を用いて、非投機的パスと投機的パスの間で観測可能な差異が生じる条件が存在するかどうかを厳密に検証する。
SPECTECTORのアプローチは、具体的かつ実証可能な反例（Counter-example）を生成できるという点で極めて強力である。攻撃者がどのような入力値を与えれば脆弱性を悪用できるかを正確に特定できるため、エクスプロイトの作成やデバッグに直結する情報を提供できる。
しかし、シンボリック実行は構造的な弱点を抱えている。それが「パス爆発（Path Explosion）」である。プログラムの分岐数が増えるにつれて、探索すべきパスの数は指数関数的に増大する。特に、ループ構造を持つプログラムにおいては、ループの回転数に応じてパスが無限に生成される可能性があるため、実質的な検証が困難となる。SPECTECTORでは、ループを有限回（例えば数回）展開する「Bounded Unrolling」によってこれを回避しようとするが、これは検証の完全性を犠牲にするものであり、展開回数を超える深さにある脆弱性を見逃すリスクがある。また、投機ウィンドウ（Speculation Window）が深い場合や、ネストされた投機が発生する場合も、制約条件が複雑化し、SMTソルバのタイムアウトを招く要因となる。

## 第III章 方法論の検証：ループ展開の破綻と抽象解釈への転換

本研究提案の核心は、SPECTECTORが直面するスケーラビリティの壁を突破するために、検証のパラダイムを「パスの列挙（シンボリック実行）」から「状態の近似（抽象解釈）」へと転換する点にある。この転換の妥当性を評価するためには、まず、研究の初期段階で検討され、そして棄却された「ループ展開仮説」の失敗原因を深く理解する必要がある。

### 3.1 ループ展開仮説の論理的破綻：偽の不動点

初期の提案では、「レジスタ数＋1回」という有限回のループ展開を行えば、システムの抽象状態（テイント状態）は不動点に達し、それ以降の検証は不要であるという仮説が立てられた。これは、「機密レベルは Low から High への一方向にしか遷移しない（単調増加性）」という前提に基づいた、いわゆる鳩の巣原理による帰結であった。
しかし、この仮説は「抽象状態の安定」と「具体状態の安定」を混同するという致命的な論理的誤謬を含んでいた。この現象は、ドキュメントにおいて「偽の不動点（False Fixed Point）」または「遅延する汚染（Delayed Taint）」として正確に特定されている。
抽象解釈において、不動点とは抽象状態 $\Sigma^\#$ が変化しなくなる状態（$\Sigma^\#_n = \Sigma^\#_{n+1}$）を指す。しかし、実際のプログラムにおける機密情報の伝播は、抽象化されたテイントラベルだけでなく、具体的な値（ループカウンタやポインタオフセットなど）に依存することが多い。
例えば、ループカウンタ i が 100 に達したときのみ、機密データを load する命令があると仮定する。

* **ステップ 1〜99:** 解析器は、ターゲットレジスタが $Low$ のままであることを観測する。抽象状態は $Low \to Low$ と遷移し、変化がないため、解析器はこれを「不動点」と誤認し、検証を打ち切る可能性がある。
* **ステップ 100:** 具体的実行において i == 100 が成立し、突如としてレジスタが $High$ に遷移する。

このように、抽象ドメイン上での見かけの安定性は、将来的な状態変化がないことを保証しない。単調性はテイントラベルそのものには成立するかもしれないが、テイントが発生する「トリガー条件」は非単調な具体的実行に依存するため、単純な有限展開では無限の未来を保証できないのである。この数学的な洞察こそが、単純な有界モデル検査を捨て、より洗練された抽象解釈フレームワークへと移行する強力な動機付けとなっている。

### 3.2 関係抽象解釈の必然性

さらに、SNI検証には「単項（Unary）」ではなく「関係（Relational）」の解析が不可欠であることも、本研究の方針転換を正当化する重要な要素である。
従来のテイント解析は、「変数 $x$ は機密か？」という属性を追跡する単項解析である。しかし、SNIは「非投機実行（NS）と投機実行（SP）の間の差異」を問う性質である。ある変数が機密データを持っていたとしても、それがNSとSPで一貫して同じ値であれば、投機による新たな漏洩（Additional Leakage）は発生していないとみなせる（Spectre攻撃の文脈では）。
したがって、解析器は2つの実行状態のペア $\langle v_{ns}, v_{sp} \rangle$ の関係性を第一級の市民として扱う必要がある。これが「関係抽象解釈」を採用する理論的根拠であり、本提案の妥当性を支える柱の一つである。

## 第IV章 提案手法の構造解析：VCFGとコンテキストスタック

本研究が提案する解決策は、 **仮想制御フローグラフ（VCFG）** 、 **投機コンテキストスタック（$\Pi^\#$）** 、および **関係抽象ドメイン（$\mathcal{L}_{SNI}$）** の三位一体による構成である。

### 4.1 仮想制御フローグラフ（VCFG）の拡張と洗練

VCFGは、通常の制御フローグラフ（CFG）に、誤予測によってのみ実行される「投機的エッジ（$E_{sp}$）」を追加したものである。この概念自体は、WuとWangによるキャッシュ解析（WCET推定）の研究に端を発するが、本研究における適用は、その目的と構造において重要な拡張を含んでいる。
WuとWangのモデルでは、VCFGはキャッシュ状態（Must-Hit解析）の安全性を保証するために用いられた。彼らの手法では、分岐予測ミスからのロールバックを表現するために、投機的実行パスから正規パスへの「バックエッジ」のような仮想的な制御フローを導入した。これにより、投機実行がキャッシュに与える副作用（Ageの増加など）を解析に取り込むことができる。
本提案では、このVCFGをSNI検証のために再定義している。重要なのは、グラフのエッジを明確に「非投機的（$E_{ns}$）」と「投機的（$E_{sp}$）」に分離し、それぞれに対して異なる抽象変換関数（Transfer Function）を適用する点である。

* **非投機的エッジ ($F_{ns}$):** ベースラインとなる正規実行の状態を更新する。
* **投機的エッジ ($F_{sp}$):** 投機的実行特有の状態遷移（逸脱）をモデル化する。

この分離により、解析器は「ある変数がNS実行では安全だが、SP実行では汚染される」というSNI特有の状況（Leak状態）を、グラフ上の経路探索として捉えることが可能になる。

### 4.2 投機コンテキストスタック（ $\Pi^\#$ ）による共有ノード問題の解決

VCFGを用いた解析における最大の課題は、「共有ノード問題（Shared Node Problem）」である。グラフ上のノード（命令）は、正規実行でも、投機実行でも、あるいは多重にネストされた投機実行でも、同じ物理的なノードとして共有される。もし解析器がコンテキスト（文脈）を管理せずにグラフを探索すると、異なる投機深さや履歴を持つ状態が混ざり合い、現実にはあり得ないパス（Infeasible Path）を解析してしまうことになる。これは、解析の精度を著しく低下させるだけでなく、誤検知（False Positive）の温床となる。
本研究で提案されている「投機コンテキストスタック（$\Pi^\#$）」は、この問題に対する決定的な解である。これは、ハードウェアのリオーダーバッファ（ROB）や投機ウィンドウの管理ロジックを、抽象解析の中でシミュレートするメカニズムである。

* **Push操作 (Rule-Spec-Entry):** 投機的エッジ $E_{sp}$ を通過する際、新たなフレーム $\langle id, WindowSize \rangle$ をスタックにプッシュする。これにより、解析器は「現在、投機モードにある」ことを認識する。
* **Pop操作 (Rule-Rollback):** ロールバックエッジを通過、あるいはウィンドウサイズが枯渇した際、スタックをポップし、投機的状態を破棄して非投機的なチェックポイント状態を復元する。
* **Guard操作:** 遷移はスタックの状態と整合性が取れている場合のみ許可される。例えば、ウィンドウサイズが0になった状態でさらに投機を深めるような遷移はブロックされる。

このスタック機構により、解析は「文脈非依存（Context-Insensitive）」から「投機文脈依存（Speculative-Context-Sensitive）」へと昇華される。これは、WuとWangの研究においても「投機深さの制限」や「マージ戦略」として触れられている概念を、SNIというより厳密な情報フロープロパティのために形式化したものと評価できる。特に、SNIは情報の「値」の依存関係を追跡する必要があるため、キャッシュ解析（状態の有無のみを問う）よりも厳密なコンテキスト管理が要求されるが、本提案のスタックはその要求を満たす設計となっている。

### 4.3 関係抽象ドメイン $\mathcal{L}_{SNI}$ と結合演算の妙

解析の精度と効率のバランスを決定づけるのが、抽象ドメインの設計である。本研究では、以下の格子（Lattice）を採用している。

$$\mathcal{L}_{SNI} = \{ \bot, EqLow, Diverge, EqHigh, Leak, \top \}$$

このドメイン設計は、SNIの要件を過不足なく表現している。

* $EqLow (\langle L, L \rangle)$: 安全。NS/SP共に公開情報。
* $Diverge (\langle L, L \rangle, v_{ns} \neq v_{sp})$: 安全。値は異なるが、共に公開情報であるため、この差異自体は秘密に依存しない（制御フローの分岐による差異など）。
* $EqHigh (\langle H, H \rangle)$: 安全。秘密情報であるが、NSとSPで一貫しているため、新たな漏洩はない。
* $Leak (\langle L, H \rangle)$: **危険**。NSでは公開情報（あるいは観測なし）だが、SPでは秘密情報が観測される。これこそがSpectre攻撃の徴候である。

**結合演算（Join, $\sqcup$）の特異性：**
ドキュメントでは、$Diverge \sqcup EqHigh = EqHigh$ という結合規則が定義されている。これは直感に反するように見えるかもしれない（「値が異なる状態」と「秘密の状態」を混ぜると「秘密の状態」になる）が、セキュリティ解析においては妥当かつ安全な近似である。セキュリティラベルにおいて $High$ は「情報量が最大（Top）」の状態であり、一度でも $High$ とみなされた変数は、それ以降の計算において常に秘密として扱われるべきだからである（汚染の吸収性）。
また、$Leak$ 状態がいかなる状態と結合しても $Leak$ を維持する（吸収的である）設計は、解析の過程で一度検出された脆弱性が、その後のパス合流によって「希釈」され、見逃されることを防ぐために不可欠な特性である。

## 第V章 SPECTECTORおよびLightSLHとの比較評価

本提案手法の立ち位置を明確にするために、既存の主要技術であるSPECTECTOR および LightSLH との比較を行う。以下の表に主要な特性の比較を示す。

| 特性 | SPECTECTOR | LightSLH (LightH) | 提案手法 (VCFG + Abstract Interpretation) |
| :--- | :--- | :--- | :--- |
| **基盤技術** | シンボリック実行 + SMT | 抽象解釈 (Taint Tracking) | 関係抽象解釈 + VCFG |
| **解析対象** | パス（Path-Sensitive） | 命令（Instruction-Sensitive） | グラフノード（Context-Sensitive） |
| **ループ処理** | 有界展開（Bounded Unrolling） | 不動点反復（Fixpoint） | 不動点反復（Fixpoint） |
| **計算量** | 指数関数的 $O(b^d)$ | 多項式時間（高速） | 多項式時間 $O(N \times H)$ |
| **結果の出力** | 正確な反例（入力値） | 脆弱な命令の特定 | 潜在的な漏洩の有無（過大近似） |
| **SNI保証** | 完全（バウンド内） | 近似（SSプロパティ） | 完全（モデル内） |
| **主な課題** | パス爆発、タイムアウト | 解析麻痺、過剰保護 | 偽陽性（False Positive）、反例生成不可 |

### 5.1 対 SPECTECTOR：精度とスケーラビリティのトレードオフ

SPECTECTORは、SMTソルバを用いることでビットレベルの精度を実現し、「どの入力値を与えれば攻撃が成立するか」という具体的な反例を生成できる。これは攻撃の実証（PoC作成）には最適である。しかし、その代償として計算コストが極めて高く、大規模なループや深い投機ウィンドウを持つプログラムに対しては事実上機能しない（タイムアウトする）。
対照的に、提案手法は抽象解釈を用いることで、状態を「集合」として扱い、詳細な値を捨象する。これにより、計算量はプログラムサイズと格子の高さに比例する多項式時間に抑えられ、無限ループを含むプログラムに対しても有限時間での停止（収束）が保証される。
トレードオフとして、抽象化に伴う情報の損失により、実際には攻撃不可能なパスを「危険」と判定する「偽陽性（False Positive）」が発生する可能性がある。また、具体的な入力値を逆算することは困難である。
したがって、提案手法は、エクスプロイトの発見ツールとしてではなく、「安全性の証明（Certification）」 や 「CI/CDパイプラインにおけるゲートキーパー」 としての位置付けが最適であると言える。

### 5.2 対 LightSLH：解析麻痺と不動点計算の共通項

LightSLH は、SLH（Speculative Load Hardening）などの防御策を適用する際のオーバーヘッドを削減するために、必要な箇所のみを保護する「ターゲット型ハードニング」を提案している。LightSLHの研究において重要な発見は、「解析麻痺（Analysis Paralysis）」という現象である。これは、投機的なメモリ書き込み（Out-of-Bounds Store）が発生すると、メモリ全体が汚染された（Top状態）とみなされ、それ以降の解析が役に立たなくなる現象を指す。
LightSLHは、この問題を解決するために「SpecHK」という不動点アルゴリズムを導入している。これは、防御策（Hardening）を適用したという仮定の下で解析を再実行し、防御によって解析麻痺が解消された状態を利用して、さらなる脆弱性を探索するという反復プロセスである。
本提案手法（VCFG上の抽象解釈）もまた、不動点計算を核としている点でLightSLHと共鳴している。LightSLHが「防御の適用セット」の不動点を求めるのに対し、本手法は「情報の流出関係」の不動点を求めるという違いはあるが、両者とも「循環的な依存関係や発散する状態を、単調な反復計算によって収束させる」という抽象解釈の強力な特性を利用している。
特に、LightSLHが指摘する「コンパイラによるスタックスピル（Register Spill）の脆弱性」は、本提案手法にとっても重要な示唆を含んでいる。LightSLHの実験では、LLVM IRレベルで安全と証明されたコードが、アセンブリへの変換時にコンパイラが挿入したスタック退避コードによって脆弱になるケースが確認された。これは、本提案手法が（SPECTECTORと同様に）ソースコードや中間表現ではなく、バイナリまたはアセンブリコードを対象としてVCFGを構築すべきであることを強く示唆している。

## 第VI章 形式的検証とアルゴリズムの妥当性

提案されたアルゴリズムの詳細について、その論理性と健全性を検証する。

### 6.1 メモリ更新の意味論：Strong Update vs. Weak Update

抽象解釈において最も誤りを犯しやすいのが、メモリへの書き込み（store）の取り扱いである。提案手法では、書き込み先のアドレスの性質に応じて更新ルールを厳密に区別している。

* **Strong Update（強更新）:** アドレスが具体的かつ単一（Singleton）であり、かつNS/SPで一致（$EqLow$）している場合のみ、メモリの抽象値を新しい値で「上書き」する。これは情報の精度を維持するために重要である。
* **Weak Update（弱更新）:** アドレスが抽象的（範囲を持つ）であったり、NS/SPで分岐（$Diverge$）している場合、既存の値と新しい値の結合（Join, $\sqcup$）をとる。

この区別は極めて妥当である。特にアドレスが $Diverge$ している場合（例：NSはアドレスAに、SPはアドレスBに書き込む）、SP実行においてアドレスAの値が書き換わったとは断定できないため、古い値が残存する可能性を考慮しなければならない。もしここでStrong Updateを行えば、SP実行では依然として機密データを保持しているかもしれないメモリ領域を「安全な値で上書きされた」と誤認し、漏洩を見逃す（Unsoundな）結果を招くことになる。提案手法のWeak Updateはこのリスクを数学的に回避している。

### 6.2 観測履歴の分離：MEMLEAKとCTRLLEAK

提案手法では、観測履歴を $\mathcal{O}^\#$ (Memory Leak) と $\mathcal{J}^\#$ (Control Leak) に分離して管理している。これはSPECTECTORのモデルと整合するものであり、攻撃者が観測できるサイドチャネルの種類（データキャッシュの競合と、命令キャッシュやBTBの競合）を正確に区別するために必要である。
更新規則 $H_{new} = H_{old} \sqcup_{sp} v_{obs}$ において、ベースライン（NS）で観測されなかった（$\bot$）情報が、SP実行で $High$ として観測された場合に $Leak$ と判定するロジックは、SNIの定義 $\mathcal{O}_{ns}(\sigma_1) = \mathcal{O}_{ns}(\sigma_2) \implies \mathcal{O}_{sp}(\sigma_1) = \mathcal{O}_{sp}(\sigma_2)$ を忠実に実装している。NSで観測がないということは、攻撃者はその時点まで情報を得ていない。その状態でSPのみが機密情報に触れる挙動を見せれば、それは新たな情報の流出に他ならないからである。

## 第VII章 今後の課題と発展的考察

### 7.1 精度向上のための拡張：シャドウ変数とワイドニング

WuとWangの研究は、キャッシュ解析の精度を向上させるために「シャドウ変数（Shadow Variables）」という概念を導入している。これは、変数の「最古の年齢（Must-Analysis）」だけでなく「最新の年齢（May-Analysis）」を同時に追跡することで、合流点での情報の損失を抑える技術である。
本提案手法においても、関係抽象ドメインにおいて同様のアプローチが有効であると考えられる。例えば、単に $Diverge$（値が異なる）とするだけでなく、「どのような条件でDivergeしたか」あるいは「Divergeした値の範囲」をシャドウ情報として保持することで、後の合流点でのマージ（Join）を遅延させたり、精度を高めたりすることが可能になるかもしれない（Trace Partitioningの一種）。
また、ループの収束を加速させるための「ワイドニング（Widening）」演算子の設計も重要である。単純な格子では高さが有限であるため必ず収束するが、ポインタ演算などで無限の高さを持つドメイン（区間ドメインなど）を導入する場合、適切なタイミングで精度を犠牲にして収束を強制するワイドニングが必要となる。WuとWangは、ループ展開とワイドニングを組み合わせることで効率的な解析を実現しており、この知見は本手法の実装フェーズにおいても参考になるだろう。

### 7.2 ポインタ演算とフロー感度

ユーザーが懸念している `ptr++` のようなポインタ演算（Case 2.4）は、メモリ領域がセキュリティレベルの異なる境界を跨ぐ際に問題となる。
* **課題:** ポインタ ptr が `(Low領域)` と `(High領域)` の両方の可能性を持つ場合、`*ptr` の読み出しは $Low \sqcup High = High$ となり、過剰な汚染（Taint Explosion）を引き起こす。
* **推奨:** これを解決するには、抽象ドメインに「値（Value）」の追跡能力、具体的には「区間解析（Interval Analysis）」を統合する必要がある。単に $R^\#$ で関係性（EqLow/Leak等）を追跡するだけでなく、その具体的な値の範囲も抽象化して保持することで、ポインタが指し示すメモリ領域をより精密に特定できる。これは LightSLH が採用している「値ドメイン（Value Domain）」と「テイントドメイン（Taint Domain）」のハイブリッドアプローチに近い。

### 7.3 マージ戦略の最適化

WuとWangの研究では、投機的パスと正規パスの状態をマージするタイミングとして、「ロールバック直後」ではなく「投機的パスの終了まで遅延させる（Just-in-Time Merging）」手法が精度向上に寄与すると報告されている。
本提案のVCFGでは、グラフ構造上でマージポイントが固定されている可能性があるが、解析アルゴリズム側で「いつマージするか」を制御する余地があるならば、Just-in-Time戦略を採用することで、不要な $Diverge$ 状態の生成を抑制し、偽陽性を減らすことができる可能性がある。

## 第VIII章 結論

本研究で提案された、仮想制御フローグラフ（VCFG）上の関係抽象解釈によるSNI検証手法は、既存のシンボリック実行ベースの手法が抱えるスケーラビリティの限界を克服するための、論理的かつ実践的な解である。
特に、単純なループ展開の不可能性を数学的に見抜き、コンテキストスタックによる厳密な投機深さの管理を導入した点は、本研究の高い技術的妥当性を示している。このアプローチは、SPECTECTORのような「完全な反例生成」能力を犠牲にする代わりに、「大規模コードに対する証明可能性」と「停止性」を提供する。これは、暗号ライブラリの全数検査や、OSカーネルのような巨大なコードベースに対するセキュリティ監査において、極めて価値の高い特性である。
さらに、LightSLHの研究から得られた知見（解析麻痺への対処、コンパイラ起因の脆弱性）を取り込むことで、本手法はより堅牢なものとなる。具体的には、ソースコードレベルではなくアセンブリレベルでの解析を徹底すること、そして不動点計算の中に「防御策の仮定」を組み込むことで解析の精度を維持することなどが、今後の実装における重要な指針となるだろう。
総じて、本研究はSpectre対策の自動化という分野において、理論と実践の両面から重要な進歩をもたらすものであり、その新規性と有効性は高く評価されるべきである。

### 引用文献
* Princepled_Detection_of_Speculative_Information_Flows.pdf
* 2025-11-17-投機的情報フロー検出アルゴリズム解説
* Abstract-Interpretation-under-Speculative-Execution.pdf
* 2025-11-20-VCFG探索における投機実行コンテキスト管理
* Place_Protections_at_the_right_place.pdf
