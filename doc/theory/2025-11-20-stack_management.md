# 大規模ループプログラムにおける投機的非干渉（SNI）検証のための仮想制御フローグラフ（VCFG）の高度化とスタック管理機構の形式化に関する研究報告書

## 第I章 序論：投機的実行の安全性検証における構造的課題

現代のプロセッサアーキテクチャにおいて、投機的実行（Speculative Execution）は性能向上のための不可欠な機能として定着している一方で、Spectre に代表される深刻なサイドチャネル脆弱性の温床となっている。これに対抗するため、プログラムが投機的実行下においても機密情報を漏洩しないことを保証する「投機的非干渉（Speculative Non-Interference, SNI）」というセキュリティ特性の検証が急務となっている。
貴殿の研究は、仮想制御フローグラフ（Virtual Control Flow Graph, VCFG）を用いた関係的抽象解釈により、このSNIを静的に検証する野心的な試みである。しかし、実装段階において指摘された「共有ノード型のVCFGでスタック管理を行わずに探索するのはナンセンスであり、異なる投機コンテキストへの不正な遷移が発生する」という批判は、静的解析の理論的根拠（Soundness）を揺るがす重大なものである。本報告書は、この指摘の妥当性を数理的かつ構造的な観点から徹底的に調査し、VCFGに基づく解析手法が大規模かつループを含むプログラムに対して健全に機能するための理論的修正案を提示することを目的とする。

### 1.1 背景：CFGからVCFGへの拡張とその陥りやすい罠

従来の静的解析は、標準的な制御フローグラフ（Control Flow Graph, CFG）上で定義される。しかし、SNI検証においては、アーキテクチャ的にはコミットされない「誤予測パス」を明示的にモデル化する必要がある。貴殿の提案するVCFG は、標準的なノード集合 $N$ に投機的エッジ $E_{sp}$ を追加することでこれを表現しようとしている。
ここで問題となるのが、非投機的（Non-Speculative, NS）実行と投機的（Speculative, SP）実行が、同一の物理的命令（ノード）を共有する「共有ノード型（Shared-Node）」のアプローチを採用している点である。文脈（Context）を区別せずにノードを共有することは、静的解析における「コンテキスト感度（Context Sensitivity）」の欠如を意味する。特に、投機的実行はその性質上、分岐予測ミスが発生した時点での「スナップショット」を保持し、一定期間（投機ウィンドウ）後に必ずロールバックするという、極めて強い時間的・状態的な制約を持つ。
指摘事項にある「異なる投機コンテキストへの不正な遷移」とは、解析器がこの時間的制約（スタック構造）を無視し、グラフのトポロジー（接続関係）のみに従って探索を行った結果、現実のプロセッサでは決して発生し得ない「投機状態から別の投機状態への飛び移り」や「投機状態からの不正なコミット」を許容してしまう現象を指している。これは、解析精度の低下（False Positiveの増大）のみならず、検証自体の信頼性を損なう致命的な欠陥となり得る。

### 1.2 本報告書の構成と分析の視座

本報告書では、以下の構成でこの問題を解剖し、解決策を提示する。
* **第II章:** SNIの形式的定義と、それが要求する「トレース間の関係性」について再確認する。特に、SPECTECTOR が採用するシンボリック実行との対比を通じて、グラフベース解析の構造的弱点を浮き彫りにする。
* **第III章:** 「問題のケース」として挙げられたループ構造を対象に、スタック管理欠如が引き起こす具体的な「不正遷移」のメカニズムを数理的に証明する。
* **第IV章:** 解決策として、抽象ドメインに「投機コンテキストスタック（Speculative Context Stack）」を導入する手法を提案する。ここでは、VCFGの構造を変えずに解析アルゴリズム側でコンテキストを制御するアプローチを採用する。
* **第V章:** 提案手法のアルゴリズムを形式化し、既存のVCFG定義との統合方法を示す。
* **第VI章:** 提案手法が、既存の関連研究（SPECTECTOR や Declassiflow）と比較してどのような位置づけにあるかを論じ、特に「事後的検証」と「事前的最適化」の観点から考察する。

## 第II章 理論的基盤：SNI検証におけるコンテキストの重要性

SNI検証の核心は、非投機的実行（NS）と投機的実行（SP）の二つの世界における「情報の流れ」を比較することにある。この比較を健全に行うためには、それぞれの実行コンテキストが厳密に隔離され、かつ適切に関連付けられていなければならない。

### 2.1 SNIの定義とハイパープロパティとしての性質

SNIは単一の実行トレースの性質ではなく、複数のトレース間の関係性を問う「ハイパープロパティ（Hyperproperty）」である。具体的には、「NS実行において観測的に等価な二つの初期状態は、SP実行においても観測的に等価なトレースを生成しなければならない」という非干渉性（Non-Interference）の拡張概念である。

**定義（Speculative Non-Interference）:**
プログラム $P$ がSNIを満たすとは、任意の二つの初期メモリ状態 $\sigma_1, \sigma_2$ について、それらが低セキュリティレベル（Low）で等価 ($\sigma_1 \approx_L \sigma_2$) であり、かつNS実行時の観測トレースが等価 ($Tr_{ns}(\sigma_1) = Tr_{ns}(\sigma_2)$) であるならば、SP実行時の観測トレースも等価 ($Tr_{sp}(\sigma_1) = Tr_{sp}(\sigma_2)$) であることを言う。

この定義が示唆するのは、解析器は「NS状態」と「SP状態」を単に保持するだけでなく、それらが「どの時点（PC）で分岐し、どのような履歴を経て現在に至ったか」という **履歴（History）の一貫性** を保証しなければならないという点である。

### 2.2 投機的実行のライフサイクルとスタック構造

現実のマイクロアーキテクチャ（例：Reorder Buffer, ROB）において、投機的実行は明確なライフサイクルを持つ。これを無視したグラフ探索は無意味である。
1.  **チェックポイント作成（Checkpointing）:** 分岐予測時に現在のアーキテクチャ状態（レジスタマップ等）のスナップショットをとる。これが「投機コンテキスト」の生成である。
2.  **投機実行（Speculative Execution）:** 予測されたパスを実行する。この間、結果はROBにバッファリングされ、外部（メモリやアーキテクチャレジスタ）への永続的な書き込みは保留される。
3.  **検証とコミット/ロールバック（Resolve）:** 分岐条件が確定した時点で、予測が正しければ結果をコミットし、誤っていればスナップショットまで巻き戻す（ロールバック）。

この構造は、本質的に **LIFO（Last-In, First-Out）のスタック構造** である。入れ子になった投機（Nested Speculation）が発生した場合、最も内側の投機から順に解決またはロールバックされなければならない。VCFG上での探索においてこのスタック構造を模倣しなければ、解析器は「内側の投機を飛び越えて外側の投機を終了する」あるいは「投機中に別の無関係な投機コンテキストへ遷移する」といった、ハードウェア的にあり得ない挙動を許容することになる。

### 2.3 VCFGの共有ノード問題：Context Insensitivity

貴殿のVCFG において、ノード $N$ はNS実行とSP実行で共有されている。これは静的解析における「コンテキスト非感度（Context-Insensitive）」な表現に近い。

| 解析モデル | ノード表現 | コンテキスト区別 | メモリ効率 | 解析精度 |
| :--- | :--- | :--- | :--- | :--- |
| 単純CFG/VCFG | $n$ | なし | 高 | 低（不正遷移あり） |
| Call-String法 | $(n, \text{history})$ | 呼び出し履歴で区別 | 中 | 中 |
| Full Polyvariance | $(n, \pi)$ | 完全な投機スタック $\pi$ で区別 | 低（状態爆発） | 高（完全） |

指摘された「ナンセンス」という言葉は、左端の「単純VCFG」モデルでSNIのような繊細なプロパティ（第2ハイパープロパティ）を検証しようとする無謀さを指していると解釈できる。特にループ構造においては、同じノード $n$ に異なる投機深さ、異なる投機原因（Branch ID）で何度も到達するため、これらを区別しない限り、解析はカオスと化す。

## 第III章 構造的欠陥の検証：「問題のケース」における不正遷移

ここでは、言及されているループ構造（機密情報がNS実行によってロードされ、SP実行によって観測されるケース）を具体例として、スタック管理のないVCFG探索がどのように破綻するかをステップバイステップで検証する。

### 3.1 ループ構造とVCFGトポロジー

以下の単純化されたループプログラムを考える。

Loop: n1: load r1, [r2] ; 共有ノード n2: beqz r1, Exit ; 分岐（投機ポイント） n3: jmp Loop ; ループバック Exit: n4:...


このプログラムのVCFG $G_{VCFG}$ は以下のエッジを持つ。
* $E_{ns}$: $(n_1, n_2), (n_2, n_4)$ (Exit), $(n_2, n_3), (n_3, n_1)$ (Loop)
* $E_{sp}$: $(n_2, n_3)$ (誤予測によるループ継続)

### 3.2 不正遷移のシミュレーション

スタック管理（投機深さやIDの追跡）を行わない単純な不動点計算アルゴリズムの挙動を追う。

* **ステップ1: 正常な投機開始**
    * 解析器は $n_2$ に到達し、投機的エッジ $(n_2, n_3) \in E_{sp}$ を選択する。
    * 状態: Mode: Speculative, Source: n2
    * 遷移: $n_2 \to n_3 \to n_1$
* **ステップ2: 投機状態での共有ノード到達**
    * 解析器は $n_1$ に到達する。この時点で状態は「投機中」である。しかし、グラフ上 $n_1$ は共有ノードであり、ここから出るエッジは $E_{ns}$ の $(n_1, n_2)$ である。
    * 問題点: 解析器は「現在 $n_1$ にいる」という事実しか知らず、「この $n_1$ は $n_2$ からの投機によって到達したものである」という文脈情報を（スタックなしでは）持たないか、持っていても活用する術がない。
* **ステップ3: 不正な分岐と「コンテキストの混合」**
    * 解析器は $n_1$ から $n_2$ へ進み、再び分岐命令に到達する。ここで以下の二つの不正なパスが発生し得る。
    * **不正なコミット（Illegal Commit）:** 解析器が $n_2$ から $E_{ns}$ の $(n_2, n_4)$ (Exit) を選択する場合。
        * 現象: 投機中（誤予測パス上）であるにもかかわらず、あたかもその実行が確定したかのようにループを抜け、後続の処理（$n_4$）へ遷移する。
        * 矛盾: 投機実行は必ずロールバックされなければならない。しかし、このパスではロールバックが発生せず、投機汚染された状態が確定パスへ漏れ出す。
    * **コンテキストの喪失（Context Loss）:** 解析器が $n_2$ から再び $E_{sp}$ を選択する場合（入れ子投機）。
        * 現象: 投機深さが加算されるべきだが、スタック管理がないため、「単なる投機状態」として処理される可能性がある。
        * 矛盾: これにより、投機ウィンドウ（Window Size）の制限が正しく機能しなくなる。無限にループを回り続け、本来ハードウェアでは到達不可能な深さまで解析が進み、存在しないリーク（Phantom Leak）を検出する。

### 3.3 結論：指摘の妥当性

以上のシミュレーションから、 **「共有ノード型のVCFGでスタック管理を行わずに探索する」ことは、投機実行のライフサイクル（開始→実行→ロールバック）をグラフ上で再現不可能にする** ことが証明された。これにより、解析器は「存在し得ないパス（Infeasible Path）」を探索することになり、検証結果の健全性を著しく損なう。したがって、指摘は極めて妥当であり、対処は必須である。

## 第IV章 解決策の提案：抽象投機スタック（Abstract Speculation Stack）の導入

この構造的欠陥を解決するためには、解析器に「現在どの投機コンテキストにいるか」を認識させ、グラフ上の遷移を適切にガード（Guard）する必要がある。本報告書では、VCFGの構造を肥大化させることなく、抽象ドメインの拡張によってこれを実現する手法を提案する。

### 4.1 拡張された抽象状態定義

局所抽象状態 $s_n^\#$ を拡張し、新たに **抽象投機スタック $\Pi^\#$** を導入する。

$$s_n^\# = (R_n^\#, \Gamma_n^\#, \mathcal{O}_n^\#, \mathcal{J}_n^\#, \Pi_n^\#)$$

ここで、各コンポーネントの役割は以下の通りである。
* $R_n^\#, \Gamma_n^\#$: レジスタおよびメモリの抽象値。
* $\mathcal{O}_n^\#, \mathcal{J}_n^\#$: 観測履歴マップ。メモリおよび制御フローのリークを検出する。
* **$\Pi_n^\#$ (新規):** 抽象投機スタック。投機コンテキストの入れ子構造を管理する。

### 4.2 抽象投機スタック $\Pi^\#$ の構造とセマンティクス

$\Pi^\#$ は、スタックフレーム $F$ のリストとして定義される。

$$\Pi^\# = [F_1, F_2, \dots, F_k]$$

ここで、$F_k$ がスタックトップ（現在のコンテキスト）を表す。各フレーム $F$ は以下の情報を持つ。

$$F = \langle \text{TriggerNode}, \text{RollbackTarget}, \text{WindowSize}, \text{ContextID} \rangle$$

* **TriggerNode:** 投機を開始した分岐命令のノードID。
* **RollbackTarget:** 投機失敗時（またはウィンドウ枯渇時）に戻るべき、NSパス上のノードID。
* **WindowSize:** 残りの投機実行可能命令数。
* **ContextID:** コンテキストを一意に識別するID（パス感度を高めるために用いる）。

#### 4.2.1 投機的エッジ ( $E_{sp}$ ) 通過時の動作：Push

$n \xrightarrow{sp} m$ の遷移において、新たなフレームをプッシュする。

$$\Pi_{new}^\# = \text{push}(\Pi_{old}^\#, \langle n, \text{Target}_{ns}(n), W_{max}, \text{new\_id}() \rangle)$$

ここで $\text{Target}_{ns}(n)$ は、分岐 $n$ における「正しい（非投機的な）遷移先」を指す。これにより、投機終了後の復帰地点を予約する。

#### 4.2.2 非投機的エッジ ( $E_{ns}$ ) 通過時の動作：Guard & Update

ここが最も重要な修正点である。共有ノード上の $E_{ns}$ エッジを通る際、無条件に遷移するのではなく、スタックの状態に応じた制御を行う。

* **ウィンドウ減算:** スタックが空でない（投機中である）場合、スタックトップの WindowSize を減算する。
    * $$F_{top}.WindowSize \leftarrow F_{top}.WindowSize - 1$$
* **遷移ガード (Guard):** もし WindowSize が 0 になった場合、グラフ上の $E_{ns}$ エッジへの遷移を禁止し、代わりに強制的に RollbackTarget への遷移（ロールバック）を発生させる。
    * $$\text{NextNode} = \begin{cases} m \in E_{ns} & \text{if } WindowSize > 0 \\ F_{top}.RollbackTarget & \text{if } WindowSize \le 0 \text{ (Forced Rollback)} \end{cases}$$

このガード機構により、投機ウィンドウを超えた無限の探索や、投機状態のまま不正にコミットパスへ流れることを防ぐことができる。

### 4.3 SPECTECTORのPath Conditionとの対応関係

SPECTECTORは、シンボリック実行において symPc（Path Condition）を用いてパスの到達可能性を管理している。本提案におけるスタック $\Pi^\#$ は、抽象解釈の枠組みにおいてこの symPc の役割を果たすものと解釈できる。

| SPECTECTOR (Symbolic Execution) | 提案手法 (Abstract Interpretation) | 役割 |
| :--- | :--- | :--- |
| symPc (Path Condition) | $\Pi^\#$ (Speculation Stack) | 現在のパスが有効であるための制約条件 |
| Assuming branch outcome | Push operation | 制約の追加（特定の分岐予測を仮定） |
| Backtracking | Pop (Rollback) operation | 制約の解除と親コンテキストへの復帰 |
| w (Speculative Window) | WindowSize in Frame | 制約が有効な範囲（寿命）の限定 |

SPECTECTORが symPc の充足可能性（Satisfiability）をSMTソルバでチェックすることでInfeasible Pathを排除するように、提案手法では $\Pi^\#$ の構造的整合性とウィンドウカウンタを用いて、グラフ上の不正なパスを排除する。この対応関係は、提案手法がSPECTECTORと同等の理論的精度（健全性）を目指す上で不可欠な視点である。

## 第V章 実装のためのアルゴリズム形式化：ガード付き不動点計算

ユーザーの要望である「理論上どのように対処するか」に対する具体的回答として、アルゴリズムを拡張した「スタック管理付き不動点計算アルゴリズム」を提示する。

### 5.1 アルゴリズムの全体像

解析は、状態 $(n, \Pi^\#)$ を単位とするWorklistアルゴリズムとして再定義される。

**アルゴリズム 2: スタック管理付きSNI検証**

* **入力:** VCFG $G$, 初期状態 $s_{init}^\#$, 最大ウィンドウ $W_{max}$
* **状態:** $\Sigma^\# : N \times \text{StackContext} \to \text{AbstractState}$
* **初期化:**
    * $W \leftarrow \{(n_{start}, \epsilon)\}$ （空スタックで開始）
    * $\Sigma^\# \leftarrow \bot$
    * $\Sigma^\#(n_{start}, \epsilon) \leftarrow s_{init}^\#$
* **反復 (While $W \neq \emptyset$):**
    * Pop $(n, \Pi)$ from $W$
    * $s_{curr} \leftarrow \Sigma^\#(n, \Pi)$
    * **Case A: ウィンドウ枯渇 (Implicit Rollback)**
        * If $\Pi \neq \epsilon \land \text{top}(\Pi).window \le 0$:
        * $n_{tgt} \leftarrow \text{top}(\Pi).RollbackTarget$
        * $\Pi_{next} \leftarrow \text{pop}(\Pi)$
        * $s_{next} \leftarrow \text{Merge}(s_{curr}, \Sigma^\#(n_{tgt}, \Pi_{next}))$
        * Update $\Sigma^\#(n_{tgt}, \Pi_{next})$ with $s_{next}$
        * Push $(n_{tgt}, \Pi_{next})$ to $W$
        * Continue (これ以上の遷移は行わない)
    * **Case B: 非投機的エッジ ($E_{ns}$) への遷移**
        * For each $m \in \text{succ}_{ns}(n)$:
        * If $\Pi \neq \epsilon$: $\Pi_{next} \leftarrow \text{decrement}(\Pi)$
        * Else: $\Pi_{next} \leftarrow \epsilon$
        * $s_{next} \leftarrow F_{ns}(s_{curr})$
        * Update $\Sigma^\#(m, \Pi_{next})$ with $s_{next}$
        * Push $(m, \Pi_{next})$ to $W$
    * **Case C: 投機的エッジ ($E_{sp}$) への遷移**
        * For each $m \in \text{succ}_{sp}(n)$:
        * $n_{ret} \leftarrow \text{succ}_{ns}(n)$ (本来のNS分岐先)
        * $\Pi_{next} \leftarrow \text{push}(\Pi, \langle n, n_{ret}, W_{max} \rangle)$
        * $s_{next} \leftarrow F_{spec}(s_{curr})$
        * Update $\Sigma^\#(m, \Pi_{next})$ with $s_{next}$
        * Push $(m, \Pi_{next})$ to $W$

### 5.2 重要な実装詳細：コンテキスト感度の調整

上記アルゴリズムにおいて、$\Sigma^\#$ のキーに $\Pi$ （スタック全体）を含めると、スタックの深さや内容が僅かに異なるだけで別状態として扱われるため、状態数が爆発する危険性がある（パス爆発問題と同様）。
実用的な実装においては、スタックの抽象化（k-limiting等）が必要となる。

* **スタック抽象化:** スタック全体をキーにするのではなく、例えば「トップの投機ID」と「現在のスタック深さ」のペア $(\text{top\_id}, \text{depth})$ だけをコンテキストキーとして用いる。
* **マージ戦略:** 同じノード $n$ において、同じコンテキストキーを持つ状態同士はJoin（$\sqcup$）する。これにより、無限のコンテキスト生成を防ぎつつ、最低限必要な「どの投機の中にいるか」という区別を維持する。

この「調整されたコンテキスト感度」こそが、指摘された「ナンセンスな探索」と「完全なパス探索（計算不能）」の中間にある、現実的な解である。

## 第VI章 比較評価と展望：既存手法との位置づけ

提案手法を、言及されている他のアプローチと比較し、その優位性と限界を明確にする。

### 6.1 vs. SPECTECTOR

* **SPECTECTOR:** シンボリック実行により、全ての可能なパス（Path Conditionが充足可能なもの）を個別に探索する。精度は極めて高いが、ループ回数やパス数に応じて計算コストが指数関数的に増大する。
* **提案手法 (Stack-Augmented VCFG):** 不動点計算に基づくため、ループを抽象化（Widening）によって高速に収束させることが可能。スタック管理により、VCFGの構造的弱点を補いつつ、SPECTECTORに近い精度（特にInfeasible Pathの排除において）を実現する。
* **結論:** 大規模プログラムにおいては、提案手法の方がスケーラビリティで勝る可能性があるが、抽象化による精度のトレードオフ（False Positiveの可能性）には注意が必要である。

### 6.2 vs. Declassiflow

Declassiflow は、「将来的にNSパスで必ず観測される情報（Non-Speculative Knowledge）」を事前解析（Pre-pass）で特定し、それをベースラインとして投機的漏洩を判定するアプローチである。

* **Declassiflow:** 「知識フロンティア」を計算するプロアクティブな手法。解析が二段階になるが、防御策（フェンス挿入など）の最適化に強い。
* **提案手法:** 投機とNS実行を同時に追跡するリアクティブな手法。スタック管理により、現在の実行が「どの程度投機的か」を動的に把握できるため、Declassiflowのような事前計算なしに、オンザフライでSNI違反を検出できる。
* **連携の可能性:** 提案手法のスタック管理に、Declassiflowの「将来の観測予測」を組み合わせることで、さらに精度を向上させることができる。例えば、スタックトップの WindowSize 内でNS観測が発生することが確定している場合、その情報を早期に Leak 判定の除外（安全な観測）に利用できる。

### 6.3 仮想ノード ( $vn\_start, vn\_stop$ ) の役割の再考

VCFG定義に含まれていた仮想ノード $vn\_start, vn\_stop$ は、本提案のスタック管理機構によって、より明確な役割を与えられる。

* $vn\_start$: アルゴリズム上の Case C (Push操作) に対応する明示的なグラフ上のマーカーとして機能する。
* $vn\_stop$: アルゴリズム上の Case A (Implicit Rollback) を明示的にグラフ上に表現したものと解釈できる。ただし、ウィンドウ切れによるロールバックは任意の場所で発生し得るため、グラフ上に静的に $vn\_stop$ を配置するだけでは不十分であり、本提案のような動的なスタック監視が依然として必要である。

## 第VII章 結論

本報告書では、共有ノード型VCFGを用いたSNI検証において指摘された「スタック管理欠如による不正遷移」の問題を深く分析した。結論として、 **この指摘は理論的に正しく、スタック管理なしには解析の健全性を保証できない** ことが確認された。
解決策として、抽象ドメインに「投機コンテキストスタック」を導入し、VCFG上の遷移を動的にガードする手法を提案した。この手法は、以下の利点を持つ。

1.  **健全性の回復:** 投機実行のライフサイクル（開始・実行・ロールバック）を正しくモデル化し、不正なコミットやクロスコンテキスト遷移を排除する。
2.  **スケーラビリティ:** グラフ構造そのものを爆発させる（Polyvariance）のではなく、抽象状態側で制御するため、メモリ効率が良い。
3.  **SPECTECTORとの整合性:** シンボリック実行におけるパス管理の概念を抽象解釈に取り入れることで、既存の信頼性の高いツールと同等の理論的基盤を確保できる。

ユーザーにおいては、直ちに解析エンジンの AbstractState 定義にスタック構造を追加し、遷移関数（Transfer Function）にウィンドウチェックとロールバックロジックを実装することを強く推奨する。これにより、提案されているSNI検証手法は、大規模で複雑なループ構造を持つプログラムに対しても、堅牢かつ高精度な解析能力を獲得するであろう。

### 引用文献
* Princepled_Detection_of_Speculative_Information_Flows.pdf
* 2025-11-17-投機的情報フロー検出アルゴリズム解説
* 2025-11-15-SNI違反検出セマンティクスの妥当性検証
