# VCFG Builder 改善計画（次フェーズ案）

第1段階の実装は完了しました。ここから追加で着手すべき変更・リファクタリングを優先度順に整理します。各項目は現行コードでの足りない点を根拠に挙げています。  
※ 本書は将来の変更計画専用とし、現行仕様や完了済みの内容は `spec` 系ドキュメントに集約します。

## A. 表示とデバッグの分かりやすさ
- **投機／ロールバックエッジに意味ラベルを付与**  
  現状 `spec` / `rollback` エッジはいずれも無ラベルで、UI が「予測ミス」「正帰還」などを表示できない。`vcfg-builder/lib/modes/*`。  
  → `label` に `mispredict`, `rollback` 理由などを設定し、ビュー層が説明ツールチップを出せるようにする。
- **投機コンテキスト ID のメタデータ化**  
  expanded モードではノード ID 末尾（例: `@spec0`）だけに依存するためパースが必要。meta モードは NS ノード共有で別構造。  
  → ノードに `specContextId` フィールドを追加し、UI/解析コアが文字列パースなしで系統を判別できるようにする（下位互換として ID も維持）。
- **「1経路ずつ」トレースモードの導入（UIデフォルトにする）**  
  目的: BFS 的に NS/Spec が交互に混在して「順序が気持ち悪い」問題を解消し、デバッグをしやすくする。  
  実装案:  
  1) `analyzeVCFG` にオプション `traceMode: "bfs" | "single-path"` を追加。`single-path` の場合、ワークリストを LIFO（または「同一分岐に入ったら spec を優先」キュー）として、1 経路を連続して消費する。状態マージの健全性は保つが、表示順を経路単位に寄せる。  
  2) UI 側（`app` 配下）でデフォルト値を `single-path` に設定し、トグル UI（例: セレクトボックスまたはトグルボタン）で `bfs` と切り替え可能にする。  
  3) トレースログにも `traceMode` をメタデータとして埋め込み、デバッグ時にどのモードで生成したかを表示。  
  4) 回帰テストを 2 モード分けて追加（現行スナップショットは `bfs`、新規で `single-path` を期待値化）。  
  注意点: モード違いでステップ数や `obs*` のラベル昇格タイミングが変わり得るため、両モードの検証ケースを用意する。下位互換としてデフォルト以外は明示選択が必要。

## B. スケーラビリティと安全性
- **投機展開の上限ガードと統計**  
  予算は `windowSize` のみで、総ノード数や再帰深さの上限チェックがない。大規模入力ではメモリ爆発の可能性がある。`vcfg-builder/lib/modes/*`。  
  → 最大ノード・エッジ数のソフトリミットと、リミット到達時の警告を `StaticGraph` 付随メタデータで返す。
- **ジャンプ先解決の拡張**  
  現状 `jmp` はラベル/即値の静的解決のみで、実行時計算に依存する形式は `ParseError` になる。`muasm-ast/lib/parser.ts`、`vcfg-builder/lib/modes/*`。  
  → 解析側が扱える抽象ジャンプ（例: 未解決を "dynamic" としてノードを立てる）を導入し、エラーではなくグラフ上のハンドリングに落とし込む。

## C. エラー伝搬とユースケース整備（現状確認を反映）
- **ユーザー向けエラーメッセージ整形（未着手）**  
  `ParseError` の detail に行番号は入る。UI 側では `lib/analysis-engine/index.ts:40-50` で例外を捕捉し、`AnalysisResult.error` にラップして返却するまで完了済み。  
  → 追加タスクはメッセージ文面のテンプレ整備とローカライズのみ（機能欠落ではない）。

- **ドキュメントと API 表面の同期（解決済み）**  
  `schemaVersion` 付与は `analyze()` ファサードで実装済み（同上）。`buildVCFG` 単体はグラフ生成の低レイヤ API と位置付ける。  
  → 今後はドキュメントの表現を「analyze() でスキーマ付与済み」に統一し、重複記述を避ける。

## D. テストと検証の拡充
- **パフォーマンス／上限テスト**  
  現在のテストは API 形状・基本分岐・spbarr などの機能確認のみで、10k 行級や大きな `windowSize` の計測がない。`vcfg-builder/tests`。  
  → 大型入力を生成するベンチと、リミット発動時の期待挙動（警告・エッジ数上限）を CI に追加。
- **スナップショットの人間可読化**  
  期待グラフを文字列比較していないため、リグレッション検知が難しい。`vcfg-builder/tests`。  
  → 代表ケースの `StaticGraph` を JSON スナップショット化し、`type` / `label` / `specOrigin` の目視確認をしやすくする。

## E. VCFG 構造表現の評価（expanded vs meta 並行運用）
- **現状**: expanded（ノード複製）と meta（NS 共有 + メタノード）を両方提供。用途別に選択する設計になった。  
  - expanded: 解析器や可視化がシンプルだがノード爆発リスク。  
  - meta: ノード爆発を抑えつつ、spec 区間をメタノードでマーキングするため解析・可視化の取り扱いが要調整。
- **次の検証ポイント**  
  1) 代表ベンチで両モードのノード・エッジ数、解析時間、UI 可読性を比較し、推奨デフォルトを決める。  
  2) `analysis-schema` / UI 表示ルールが両モードの混在を許容するか確認し、足りないフィールド（例: `specContextId`）を検討。  
  3) モードごとに期待グラフをスナップショット化し、回帰テストを追加。  
  4) ノード爆発対策や上限ガード（節 B）を、モード別に最適な閾値で実装。
